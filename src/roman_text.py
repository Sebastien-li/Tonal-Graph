""" Module for the RomanText class """
from fractions import Fraction
import pickle
import music21
import pandas as pd
from src.tonal_graph import TonalGraph
from src.utils import display_float
from src.music_theory_classes import Pitch, Quality
from src.music_theory_objects import major_mode, minor_mode, qualities

class RomanText:
    """ Class for the roman text representation of an analysis """
    def __init__(self):
        self.text = ''
        self.rn_list = []
        self.where_wrong_key = []
        self.where_wrong_degree = []
        self.where_wrong_quality = []

    @classmethod
    def from_pickle(cls, file_path):
        """ Creates a roman text from a pickle file """
        with open(file_path, 'rb') as f:
            return pickle.load(f)


    @classmethod
    def from_rntxt(cls, file_path):
        """ Creates a roman text from a rntxt file """
        rtxt = music21.converter.parse(file_path, format="romantext")
        rtxt = rtxt.recurse().stream().getElementsByClass(music21.roman.RomanNumeral).stream()
        roman_text = cls()
        with open(file_path, 'r', encoding='utf-8') as f:
            roman_text.text = f.read()
        roman_text.rn_list = [RomanNumeral.from_music21_rn(untonicize(rn),
                                qualities, [major_mode, minor_mode]) for rn in rtxt]
        return roman_text

    @classmethod
    def from_csv(cls, file_path):
        """ Creates a roman text from a csv file """
        df = pd.read_csv(file_path).dropna(subset=['offset'])
        roman_text = cls()
        previous_rn = df.iloc[0]["RomanNumeral31"]
        previous_key = df.iloc[0]["TonicizedKey38"]
        current_offset = 0
        for row in df.iterrows():
            if row[1]["RomanNumeral31"] != previous_rn or row[1]["TonicizedKey38"] != previous_key:
                music21_rn = music21.roman.RomanNumeral(
                    previous_rn.replace('Cad','I64'),
                    previous_key,
                    offset=current_offset,
                    quarterLength= row[1]["offset"] - current_offset)
                music21_rn = untonicize(music21_rn)
                rn = RomanNumeral.from_music21_rn(music21_rn, qualities, [major_mode, minor_mode])
                roman_text.rn_list.append(rn)
                current_offset = row[1]["offset"]
            previous_rn = row[1]["RomanNumeral31"]
            previous_key = row[1]["TonicizedKey38"]

        music21_rn = music21.roman.RomanNumeral(
            previous_rn.replace('Cad','I64'),
            previous_key,
            offset=current_offset,
            quarterLength= df.iloc[-1]["offset"] - current_offset)
        rn = RomanNumeral.from_music21_rn(music21_rn, qualities, [major_mode, minor_mode])
        roman_text.rn_list.append(rn)
        return roman_text

    @classmethod
    def from_tonal_graph(cls, tonal_graph:TonalGraph):
        """ Creates a roman text from a tonal graph"""
        roman_text = cls()
        roman_text.rn_list = [RomanNumeral.from_tonal_graph_node(tonal_graph, node['id'])
                              for node in tonal_graph.shortest_path]

        text = f'Composer: {tonal_graph.rt.note_graph.score.composer}'\
               f'\nTitle: {tonal_graph.rt.note_graph.score.title}'\
               f'\nAnalyst: Automatically generated by the Tonal Graph method\n'

        current_tonality = ''
        current_chord = (0,0,0,0)
        current_measure = -1
        current_time_sig = ''
        for i, node in enumerate(tonal_graph.shortest_path):
            rn = roman_text.rn_list[i]
            real_onset = Fraction(node['onset'],tonal_graph.duration_divisor)
            measure, beat = tonal_graph.rt.note_graph.score.onset_to_measure_and_beat(real_onset)
            time_sig = tonal_graph.rt.note_graph.score.onset_to_ts(real_onset).ratioString
            beat = display_float(beat, 2)
            measure_label = measure[1]
            pitch = Pitch(int(node['tonic_diatonic']),int(node['tonic_chromatic']))
            if time_sig != current_time_sig:
                text += f'\nTime Signature: {time_sig}\n'
                current_time_sig = time_sig
            if measure_label != current_measure:
                text += f'\nm{measure_label} '
            if current_tonality != f"{pitch}{node['mode']}":
                text += f"{str(pitch).upper() if node['mode']=='M' else str(pitch).lower()}: "
            if current_chord != repr(rn):
                text += f"b{beat} " if beat != "1" else ""
                text += f"{rn.full_name} "

            current_tonality = f'{pitch}{node["mode"]}'
            current_measure = measure_label
            current_chord = repr(rn)
        roman_text.text = text
        return roman_text

    def __repr__(self):
        return self.text

    def __str__(self):
        return self.text

    def save(self, file_path):
        """ Save the roman text to a file """
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(self.text)

    def compare(self, other):
        """ Compare with another roman text """
        self_idx = 0
        m21_idx = 0
        accuracy = 0
        key_degree_accuracy = 0
        key_accuracy = 0
        duration_sum = 0
        while True:
            if self_idx >= len(self.rn_list) or m21_idx >= len(other.rn_list) :
                break
            self_rn = self.rn_list[self_idx]
            m21_rn = other.rn_list[m21_idx]
            onset = float(max(self_rn.onset, m21_rn.onset))
            duration = float(min(self_rn.duration, m21_rn.duration))
            duration_sum += duration
            if (self_rn.key_tonic, self_rn.mode) != (m21_rn.key_tonic, m21_rn.mode):
                self.where_wrong_key.append((onset, duration))
            elif self_rn.degree != m21_rn.degree:
                self.where_wrong_degree.append((onset, duration))
                key_accuracy += duration
            elif self_rn.quality != m21_rn.quality:
                self.where_wrong_quality.append((onset, duration))
                key_accuracy += duration
                key_degree_accuracy += duration
            else:
                accuracy += duration
                key_accuracy += duration
                key_degree_accuracy += duration
            next_rn_onset = self.rn_list[self_idx + 1].onset if self_idx + 1 < len(self.rn_list) else self.rn_list[self_idx].onset + self.rn_list[self_idx].duration
            next_m21_onset = other.rn_list[m21_idx + 1].onset if m21_idx + 1 < len(other.rn_list) else other.rn_list[m21_idx].onset + other.rn_list[m21_idx].duration
            if next_rn_onset <= next_m21_onset:
                self_idx += 1
            if next_rn_onset >= next_m21_onset:
                m21_idx += 1
        accuracy /= duration_sum
        key_accuracy /= duration_sum
        key_degree_accuracy /= duration_sum
        return accuracy, key_accuracy, key_degree_accuracy

    def save_pickle(self, file_path):
        """ Save the roman text to a pickle file """
        with open(file_path, 'wb') as f:
            pickle.dump(self, f)

class RomanNumeral:
    """ Class for a roman numeral with the inversion and the key"""
    def __init__(self, degree, figure, quality, inversion, key_tonic, mode, onset=0, duration=1):
                                    #Example : viio/65 in D minor
        self.degree = degree                    # VII
        self.figure = figure                    # viio/7
        self.quality = quality                  # o/7
        self.inversion = inversion              # 1
        self.key_tonic = key_tonic              # D
        self.mode = mode                        # minor
        self.key_tonic_disp = str(key_tonic).upper() if mode == 'M' else str(key_tonic).lower() # d
        self.full_name = self.get_full_name()   # viio/65
        self.full_name_with_key = self.get_full_name_with_key()    # d: viio/65
        self.onset = onset                      # Fraction in quarter length
        self.duration = duration                # Fraction in quarter length

    def get_full_name(self):
        """ Returns the full name of the roman numeral"""
        if self.quality.cardinality == 3:
            tg_inversion_name = ['','6','64'][self.inversion]
            full_name = self.figure + tg_inversion_name
        elif self.quality.cardinality  == 4:
            tg_inversion_name = ['7','65','43','2'][self.inversion]
            full_name = self.figure.replace('7',tg_inversion_name)
        else:
            full_name = 'NO'
        return full_name

    def get_full_name_with_key(self):
        """ Returns the full name of the roman numeral with the key"""
        return f'{self.key_tonic_disp}: {self.full_name}'

    def __repr__(self):
        return self.full_name_with_key

    def __eq__(self, other):
        key = ('figure', 'key_tonic', 'mode')
        return all(getattr(self, k) == getattr(other, k) for k in key)

    @classmethod
    def from_tonal_graph_node(cls, tonal_graph:TonalGraph, node_idx:int):
        """Transforms a tonal graph node into a RomanNumeral object"""
        node = tonal_graph.nodes[node_idx]
        key_tonic = Pitch(int(node['tonic_diatonic']),int(node['tonic_chromatic']))
        tg_mode = [x for x in tonal_graph.mode_list if x.name == node['mode']][0]
        tg_rn_figure = [rn for rn in tg_mode if rn.label == node['label']][0]
        degree = tg_rn_figure.figure
        figure = tg_rn_figure.label
        quality = tonal_graph.qualities[tg_rn_figure.quality]
        inversion = node['inversion']
        onset = Fraction(node['onset'],tonal_graph.duration_divisor)
        duration = Fraction(node['duration'],tonal_graph.duration_divisor)
        return cls(degree, figure, quality, inversion, key_tonic, node['mode'], onset, duration)

    @classmethod
    def from_music21_rn(cls, rn:music21.roman.RomanNumeral, qualities, mode_list):
        """Transforms a music21 roman numeral into a RomanNumeral object"""
        onset = Fraction(rn.offset)
        duration = Fraction(rn.quarterLength)
        key_tonic = Pitch.from_name(rn.key.tonic.name)
        mode = 'M' if rn.key.mode=='major' else 'm'
        mode = [x for x in mode_list if x.name == mode][0]
        degree = ['I','II','III','IV','V','VI','VII'][rn.scaleDegree-1]
        try:
            quality = [qualities[q.quality] for q in mode.roman_numeral_list
                       if qualities[q.quality].name == rn.commonName][0]
            if rn.figure in ['bII','N','Nap']:
                figure = [r for r in mode.roman_numeral_list
                          if r.figure == 'N'][0].label
            elif rn.romanNumeral in ['Fr','Ger','It']:
                figure = [r for r in mode.roman_numeral_list
                          if r.figure == rn.romanNumeral][0].label
            else:
                figure = [r for r in mode.roman_numeral_list
                          if r.quality == quality.label and r.figure == degree][0].label
        except IndexError:
            return cls(degree, 'NO', Quality(), rn.inversion(),
                       key_tonic, mode.name, onset, duration)

        return cls(degree, figure, quality, rn.inversion(), key_tonic, mode.name, onset, duration)



def untonicize(rn: music21.roman.RomanNumeral):
    """ Removes tonicization from a music21 roman numeral """
    if rn.secondaryRomanNumeral is None:
        return rn
    new_key = rn.secondaryRomanNumeralKey
    return music21.roman.RomanNumeral(rn.primaryFigure, new_key,
                                      offset = rn.offset, quarterLength = rn.quarterLength)
